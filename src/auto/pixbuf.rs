// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use Colorspace;
use Error;
use InterpType;
use PixbufFormat;
use PixbufRotation;
use ffi;
use gio;
use glib;
use glib::GString;
use glib::StaticType;
use glib::Value;
use glib::object::IsA;
use glib::translate::*;
use gobject_ffi;
use std::fmt;
use std::ptr;

glib_wrapper! {
    pub struct Pixbuf(Object<ffi::GdkPixbuf, PixbufClass>) @implements gio::Icon, gio::LoadableIcon;

    match fn {
        get_type => || ffi::gdk_pixbuf_get_type(),
    }
}

impl Pixbuf {
    pub fn new(colorspace: Colorspace, has_alpha: bool, bits_per_sample: i32, width: i32, height: i32) -> Option<Pixbuf> {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_new(colorspace.to_glib(), has_alpha.to_glib(), bits_per_sample, width, height))
        }
    }

    #[cfg(any(feature = "v2_32", feature = "dox"))]
    pub fn new_from_bytes(data: &glib::Bytes, colorspace: Colorspace, has_alpha: bool, bits_per_sample: i32, width: i32, height: i32, rowstride: i32) -> Pixbuf {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_new_from_bytes(data.to_glib_none().0, colorspace.to_glib(), has_alpha.to_glib(), bits_per_sample, width, height, rowstride))
        }
    }

    //pub fn new_from_data<'a, P: Into<Option<&'a /*Unimplemented*/PixbufDestroyNotify>>, Q: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(data: &[u8], colorspace: Colorspace, has_alpha: bool, bits_per_sample: i32, width: i32, height: i32, rowstride: i32, destroy_fn: P, destroy_fn_data: Q) -> Pixbuf {
    //    unsafe { TODO: call ffi::gdk_pixbuf_new_from_data() }
    //}

    #[cfg_attr(feature = "v2_32", deprecated)]
    pub fn new_from_inline(data: &[u8], copy_pixels: bool) -> Result<Pixbuf, Error> {
        let data_length = data.len() as i32;
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::gdk_pixbuf_new_from_inline(data_length, data.to_glib_none().0, copy_pixels.to_glib(), &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    pub fn new_from_resource(resource_path: &str) -> Result<Pixbuf, Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::gdk_pixbuf_new_from_resource(resource_path.to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    pub fn new_from_resource_at_scale(resource_path: &str, width: i32, height: i32, preserve_aspect_ratio: bool) -> Result<Pixbuf, Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::gdk_pixbuf_new_from_resource_at_scale(resource_path.to_glib_none().0, width, height, preserve_aspect_ratio.to_glib(), &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    pub fn new_from_stream<'a, P: IsA<gio::InputStream>, Q: IsA<gio::Cancellable> + 'a, R: Into<Option<&'a Q>>>(stream: &P, cancellable: R) -> Result<Pixbuf, Error> {
        let cancellable = cancellable.into();
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::gdk_pixbuf_new_from_stream(stream.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    pub fn new_from_stream_at_scale<'a, P: IsA<gio::InputStream>, Q: IsA<gio::Cancellable> + 'a, R: Into<Option<&'a Q>>>(stream: &P, width: i32, height: i32, preserve_aspect_ratio: bool, cancellable: R) -> Result<Pixbuf, Error> {
        let cancellable = cancellable.into();
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::gdk_pixbuf_new_from_stream_at_scale(stream.as_ref().to_glib_none().0, width, height, preserve_aspect_ratio.to_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    pub fn new_from_xpm_data(data: &[&str]) -> Pixbuf {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_new_from_xpm_data(data.to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_36_8", feature = "dox"))]
    pub fn calculate_rowstride(colorspace: Colorspace, has_alpha: bool, bits_per_sample: i32, width: i32, height: i32) -> i32 {
        unsafe {
            ffi::gdk_pixbuf_calculate_rowstride(colorspace.to_glib(), has_alpha.to_glib(), bits_per_sample, width, height)
        }
    }

    //#[cfg_attr(feature = "v2_32", deprecated)]
    //pub fn from_pixdata(pixdata: /*Ignored*/&Pixdata, copy_pixels: bool) -> Result<Pixbuf, Error> {
    //    unsafe { TODO: call ffi::gdk_pixbuf_from_pixdata() }
    //}

    pub fn get_formats() -> Vec<PixbufFormat> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gdk_pixbuf_get_formats())
        }
    }
}

pub const NONE_PIXBUF: Option<&Pixbuf> = None;

pub trait PixbufExt: 'static {
    fn add_alpha(&self, substitute_color: bool, r: u8, g: u8, b: u8) -> Option<Pixbuf>;

    fn apply_embedded_orientation(&self) -> Option<Pixbuf>;

    fn composite<P: IsA<Pixbuf>>(&self, dest: &P, dest_x: i32, dest_y: i32, dest_width: i32, dest_height: i32, offset_x: f64, offset_y: f64, scale_x: f64, scale_y: f64, interp_type: InterpType, overall_alpha: i32);

    fn composite_color<P: IsA<Pixbuf>>(&self, dest: &P, dest_x: i32, dest_y: i32, dest_width: i32, dest_height: i32, offset_x: f64, offset_y: f64, scale_x: f64, scale_y: f64, interp_type: InterpType, overall_alpha: i32, check_x: i32, check_y: i32, check_size: i32, color1: u32, color2: u32);

    fn composite_color_simple(&self, dest_width: i32, dest_height: i32, interp_type: InterpType, overall_alpha: i32, check_size: i32, color1: u32, color2: u32) -> Option<Pixbuf>;

    fn copy(&self) -> Option<Pixbuf>;

    fn copy_area<P: IsA<Pixbuf>>(&self, src_x: i32, src_y: i32, width: i32, height: i32, dest_pixbuf: &P, dest_x: i32, dest_y: i32);

    #[cfg(any(feature = "v2_36", feature = "dox"))]
    fn copy_options<P: IsA<Pixbuf>>(&self, dest_pixbuf: &P) -> bool;

    fn fill(&self, pixel: u32);

    fn flip(&self, horizontal: bool) -> Option<Pixbuf>;

    fn get_bits_per_sample(&self) -> i32;

    fn get_byte_length(&self) -> usize;

    fn get_colorspace(&self) -> Colorspace;

    fn get_has_alpha(&self) -> bool;

    fn get_height(&self) -> i32;

    fn get_n_channels(&self) -> i32;

    fn get_option(&self, key: &str) -> Option<GString>;

    //#[cfg(any(feature = "v2_32", feature = "dox"))]
    //fn get_options(&self) -> /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 };

    fn get_rowstride(&self) -> i32;

    fn get_width(&self) -> i32;

    fn new_subpixbuf(&self, src_x: i32, src_y: i32, width: i32, height: i32) -> Option<Pixbuf>;

    #[cfg(any(feature = "v2_32", feature = "dox"))]
    fn read_pixel_bytes(&self) -> Option<glib::Bytes>;

    #[cfg(any(feature = "v2_36", feature = "dox"))]
    fn remove_option(&self, key: &str) -> bool;

    fn rotate_simple(&self, angle: PixbufRotation) -> Option<Pixbuf>;

    fn saturate_and_pixelate<P: IsA<Pixbuf>>(&self, dest: &P, saturation: f32, pixelate: bool);

    //fn save<'a, P: Into<Option<&'a Error>>>(&self, filename: &str, type_: &str, error: P, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> bool;

    //fn save_to_buffer<'a, P: Into<Option<&'a Error>>>(&self, type_: &str, error: P, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<Vec<u8>>;

    //fn save_to_callback<'a, P: Into<Option</*Unimplemented*/Fundamental: Pointer>>, Q: Into<Option<&'a Error>>>(&self, save_func: /*Unknown conversion*//*Unimplemented*/PixbufSaveFunc, user_data: P, type_: &str, error: Q, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> bool;

    //fn save_to_callbackv<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(&self, save_func: /*Unknown conversion*//*Unimplemented*/PixbufSaveFunc, user_data: P, type_: &str, option_keys: &[&str], option_values: &[&str]) -> Result<(), Error>;

    //fn save_to_stream<'a, 'b, P: IsA<gio::OutputStream>, Q: IsA<gio::Cancellable> + 'a, R: Into<Option<&'a Q>>, S: Into<Option<&'b Error>>>(&self, stream: &P, type_: &str, cancellable: R, error: S, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> bool;

    //fn save_to_stream_async<'a, P: IsA<gio::OutputStream>, Q: IsA<gio::Cancellable> + 'a, R: Into<Option<&'a Q>>, S: FnOnce(Result<(), Error>) + Send + 'static>(&self, stream: &P, type_: &str, cancellable: R, callback: S, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs);

    //#[cfg(feature = "futures")]
    //fn save_to_stream_async_future<P: IsA<gio::OutputStream> + Clone + 'static, Q: IsA<gio::Cancellable> + Clone + 'static>(&self, stream: &P, type_: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Box_<futures_core::Future<Item = (Self, ()), Error = (Self, Error)>> where Self: Sized + Clone;

    fn scale<P: IsA<Pixbuf>>(&self, dest: &P, dest_x: i32, dest_y: i32, dest_width: i32, dest_height: i32, offset_x: f64, offset_y: f64, scale_x: f64, scale_y: f64, interp_type: InterpType);

    fn scale_simple(&self, dest_width: i32, dest_height: i32, interp_type: InterpType) -> Option<Pixbuf>;

    fn set_option(&self, key: &str, value: &str) -> bool;

    fn get_property_pixel_bytes(&self) -> Option<glib::Bytes>;

    //fn get_property_pixels(&self) -> /*Unimplemented*/Fundamental: Pointer;
}

impl<O: IsA<Pixbuf>> PixbufExt for O {
    fn add_alpha(&self, substitute_color: bool, r: u8, g: u8, b: u8) -> Option<Pixbuf> {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_add_alpha(const_override(self.as_ref().to_glib_none().0), substitute_color.to_glib(), r, g, b))
        }
    }

    fn apply_embedded_orientation(&self) -> Option<Pixbuf> {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_apply_embedded_orientation(self.as_ref().to_glib_none().0))
        }
    }

    fn composite<P: IsA<Pixbuf>>(&self, dest: &P, dest_x: i32, dest_y: i32, dest_width: i32, dest_height: i32, offset_x: f64, offset_y: f64, scale_x: f64, scale_y: f64, interp_type: InterpType, overall_alpha: i32) {
        unsafe {
            ffi::gdk_pixbuf_composite(const_override(self.as_ref().to_glib_none().0), dest.as_ref().to_glib_none().0, dest_x, dest_y, dest_width, dest_height, offset_x, offset_y, scale_x, scale_y, interp_type.to_glib(), overall_alpha);
        }
    }

    fn composite_color<P: IsA<Pixbuf>>(&self, dest: &P, dest_x: i32, dest_y: i32, dest_width: i32, dest_height: i32, offset_x: f64, offset_y: f64, scale_x: f64, scale_y: f64, interp_type: InterpType, overall_alpha: i32, check_x: i32, check_y: i32, check_size: i32, color1: u32, color2: u32) {
        unsafe {
            ffi::gdk_pixbuf_composite_color(const_override(self.as_ref().to_glib_none().0), dest.as_ref().to_glib_none().0, dest_x, dest_y, dest_width, dest_height, offset_x, offset_y, scale_x, scale_y, interp_type.to_glib(), overall_alpha, check_x, check_y, check_size, color1, color2);
        }
    }

    fn composite_color_simple(&self, dest_width: i32, dest_height: i32, interp_type: InterpType, overall_alpha: i32, check_size: i32, color1: u32, color2: u32) -> Option<Pixbuf> {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_composite_color_simple(const_override(self.as_ref().to_glib_none().0), dest_width, dest_height, interp_type.to_glib(), overall_alpha, check_size, color1, color2))
        }
    }

    fn copy(&self) -> Option<Pixbuf> {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_copy(const_override(self.as_ref().to_glib_none().0)))
        }
    }

    fn copy_area<P: IsA<Pixbuf>>(&self, src_x: i32, src_y: i32, width: i32, height: i32, dest_pixbuf: &P, dest_x: i32, dest_y: i32) {
        unsafe {
            ffi::gdk_pixbuf_copy_area(const_override(self.as_ref().to_glib_none().0), src_x, src_y, width, height, dest_pixbuf.as_ref().to_glib_none().0, dest_x, dest_y);
        }
    }

    #[cfg(any(feature = "v2_36", feature = "dox"))]
    fn copy_options<P: IsA<Pixbuf>>(&self, dest_pixbuf: &P) -> bool {
        unsafe {
            from_glib(ffi::gdk_pixbuf_copy_options(self.as_ref().to_glib_none().0, dest_pixbuf.as_ref().to_glib_none().0))
        }
    }

    fn fill(&self, pixel: u32) {
        unsafe {
            ffi::gdk_pixbuf_fill(self.as_ref().to_glib_none().0, pixel);
        }
    }

    fn flip(&self, horizontal: bool) -> Option<Pixbuf> {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_flip(const_override(self.as_ref().to_glib_none().0), horizontal.to_glib()))
        }
    }

    fn get_bits_per_sample(&self) -> i32 {
        unsafe {
            ffi::gdk_pixbuf_get_bits_per_sample(const_override(self.as_ref().to_glib_none().0))
        }
    }

    fn get_byte_length(&self) -> usize {
        unsafe {
            ffi::gdk_pixbuf_get_byte_length(const_override(self.as_ref().to_glib_none().0))
        }
    }

    fn get_colorspace(&self) -> Colorspace {
        unsafe {
            from_glib(ffi::gdk_pixbuf_get_colorspace(const_override(self.as_ref().to_glib_none().0)))
        }
    }

    fn get_has_alpha(&self) -> bool {
        unsafe {
            from_glib(ffi::gdk_pixbuf_get_has_alpha(const_override(self.as_ref().to_glib_none().0)))
        }
    }

    fn get_height(&self) -> i32 {
        unsafe {
            ffi::gdk_pixbuf_get_height(const_override(self.as_ref().to_glib_none().0))
        }
    }

    fn get_n_channels(&self) -> i32 {
        unsafe {
            ffi::gdk_pixbuf_get_n_channels(const_override(self.as_ref().to_glib_none().0))
        }
    }

    fn get_option(&self, key: &str) -> Option<GString> {
        unsafe {
            from_glib_none(ffi::gdk_pixbuf_get_option(self.as_ref().to_glib_none().0, key.to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v2_32", feature = "dox"))]
    //fn get_options(&self) -> /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 } {
    //    unsafe { TODO: call ffi::gdk_pixbuf_get_options() }
    //}

    fn get_rowstride(&self) -> i32 {
        unsafe {
            ffi::gdk_pixbuf_get_rowstride(const_override(self.as_ref().to_glib_none().0))
        }
    }

    fn get_width(&self) -> i32 {
        unsafe {
            ffi::gdk_pixbuf_get_width(const_override(self.as_ref().to_glib_none().0))
        }
    }

    fn new_subpixbuf(&self, src_x: i32, src_y: i32, width: i32, height: i32) -> Option<Pixbuf> {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_new_subpixbuf(self.as_ref().to_glib_none().0, src_x, src_y, width, height))
        }
    }

    #[cfg(any(feature = "v2_32", feature = "dox"))]
    fn read_pixel_bytes(&self) -> Option<glib::Bytes> {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_read_pixel_bytes(const_override(self.as_ref().to_glib_none().0)))
        }
    }

    #[cfg(any(feature = "v2_36", feature = "dox"))]
    fn remove_option(&self, key: &str) -> bool {
        unsafe {
            from_glib(ffi::gdk_pixbuf_remove_option(self.as_ref().to_glib_none().0, key.to_glib_none().0))
        }
    }

    fn rotate_simple(&self, angle: PixbufRotation) -> Option<Pixbuf> {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_rotate_simple(const_override(self.as_ref().to_glib_none().0), angle.to_glib()))
        }
    }

    fn saturate_and_pixelate<P: IsA<Pixbuf>>(&self, dest: &P, saturation: f32, pixelate: bool) {
        unsafe {
            ffi::gdk_pixbuf_saturate_and_pixelate(const_override(self.as_ref().to_glib_none().0), dest.as_ref().to_glib_none().0, saturation, pixelate.to_glib());
        }
    }

    //fn save<'a, P: Into<Option<&'a Error>>>(&self, filename: &str, type_: &str, error: P, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> bool {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save() }
    //}

    //fn save_to_buffer<'a, P: Into<Option<&'a Error>>>(&self, type_: &str, error: P, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<Vec<u8>> {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save_to_buffer() }
    //}

    //fn save_to_callback<'a, P: Into<Option</*Unimplemented*/Fundamental: Pointer>>, Q: Into<Option<&'a Error>>>(&self, save_func: /*Unknown conversion*//*Unimplemented*/PixbufSaveFunc, user_data: P, type_: &str, error: Q, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> bool {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save_to_callback() }
    //}

    //fn save_to_callbackv<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(&self, save_func: /*Unknown conversion*//*Unimplemented*/PixbufSaveFunc, user_data: P, type_: &str, option_keys: &[&str], option_values: &[&str]) -> Result<(), Error> {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save_to_callbackv() }
    //}

    //fn save_to_stream<'a, 'b, P: IsA<gio::OutputStream>, Q: IsA<gio::Cancellable> + 'a, R: Into<Option<&'a Q>>, S: Into<Option<&'b Error>>>(&self, stream: &P, type_: &str, cancellable: R, error: S, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> bool {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save_to_stream() }
    //}

    //fn save_to_stream_async<'a, P: IsA<gio::OutputStream>, Q: IsA<gio::Cancellable> + 'a, R: Into<Option<&'a Q>>, S: FnOnce(Result<(), Error>) + Send + 'static>(&self, stream: &P, type_: &str, cancellable: R, callback: S, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save_to_stream_async() }
    //}

    //#[cfg(feature = "futures")]
    //fn save_to_stream_async_future<P: IsA<gio::OutputStream> + Clone + 'static, Q: IsA<gio::Cancellable> + Clone + 'static>(&self, stream: &P, type_: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Box_<futures_core::Future<Item = (Self, ()), Error = (Self, Error)>> where Self: Sized + Clone {
        //use gio::GioFuture;
        //use fragile::Fragile;

        //let stream = stream.clone();
        //let type_ = String::from(type_);
        //GioFuture::new(self, move |obj, send| {
        //    let cancellable = gio::Cancellable::new();
        //    let send = Fragile::new(send);
        //    let obj_clone = Fragile::new(obj.clone());
        //    obj.save_to_stream_async(
        //         &stream,
        //         &type_,
        //         Some(&cancellable),
        //         ,
        //         move |res| {
        //             let obj = obj_clone.into_inner();
        //             let res = res.map(|v| (obj.clone(), v)).map_err(|v| (obj.clone(), v));
        //             let _ = send.into_inner().send(res);
        //         },
        //    );

        //    cancellable
        //})
    //}

    fn scale<P: IsA<Pixbuf>>(&self, dest: &P, dest_x: i32, dest_y: i32, dest_width: i32, dest_height: i32, offset_x: f64, offset_y: f64, scale_x: f64, scale_y: f64, interp_type: InterpType) {
        unsafe {
            ffi::gdk_pixbuf_scale(const_override(self.as_ref().to_glib_none().0), dest.as_ref().to_glib_none().0, dest_x, dest_y, dest_width, dest_height, offset_x, offset_y, scale_x, scale_y, interp_type.to_glib());
        }
    }

    fn scale_simple(&self, dest_width: i32, dest_height: i32, interp_type: InterpType) -> Option<Pixbuf> {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_scale_simple(const_override(self.as_ref().to_glib_none().0), dest_width, dest_height, interp_type.to_glib()))
        }
    }

    fn set_option(&self, key: &str, value: &str) -> bool {
        unsafe {
            from_glib(ffi::gdk_pixbuf_set_option(self.as_ref().to_glib_none().0, key.to_glib_none().0, value.to_glib_none().0))
        }
    }

    fn get_property_pixel_bytes(&self) -> Option<glib::Bytes> {
        unsafe {
            let mut value = Value::from_type(<glib::Bytes as StaticType>::static_type());
            gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut gobject_ffi::GObject, b"pixel-bytes\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get()
        }
    }

    //fn get_property_pixels(&self) -> /*Unimplemented*/Fundamental: Pointer {
    //    unsafe {
    //        let mut value = Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut gobject_ffi::GObject, b"pixels\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().unwrap()
    //    }
    //}
}

impl fmt::Display for Pixbuf {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Pixbuf")
    }
}
